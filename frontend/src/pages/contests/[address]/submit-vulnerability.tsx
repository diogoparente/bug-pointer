import Button from "@/components/button";
import { ContestHeader } from "@/components/contest-header";
import { DefaultBackground } from "@/components/default-background";
import { Input } from "@/components/input";
import { Page } from "@/components/page";
import { TextArea } from "@/components/text-area";
import { useForm } from "react-hook-form";
import { GetServerSideProps } from "next";
import { getContestByAddress } from "@/database/entities";
import { useRouter } from "next/router";
import { useAccount } from "wagmi";
import { useEffect, useState } from "react";
import { Alchemy, Network } from "alchemy-sdk";
import { SubHeader } from "@/components/text";

type ContestProps = {
  contest: Contest;
};

const defaultValues: SubmittedVulnerability = {
  id: 0,
  contestAddress: "",
  name: "",
  proofOfConcept: "",
  ownerAddress: "",
};

const config = {
  apiKey: "c1DyHzZUq26hycFCJTXg2oCnP-kur0Iy",
  network: Network.MATIC_MAINNET,
};

const SubmitVulnerability = ({ contest }: ContestProps) => {
  const { register, handleSubmit } = useForm<SubmittedVulnerability>({ defaultValues });
  const [error, setError] = useState("");

  const router = useRouter();
  const { address } = useAccount();

  const alchemy = new Alchemy(config);

  useEffect(() => {
    const fetchNFTS = async () => {
      let ownedNFTsBasis;
      if (address) {
        ownedNFTsBasis = (await alchemy.nft.getNftsForOwner(address)).ownedNfts;
      }
      return ownedNFTsBasis;
    };

    fetchNFTS().then((ownedNFTs) => {
      if (ownedNFTs) {
        const hasHackerPass = ownedNFTs.some(
          (nft) => nft.contract.address.toLowerCase() === "0x6Fcd41fF1f24CbEF51E492fB4B63c56aBf2B2c14".toLowerCase()
        );
        !hasHackerPass && setError("You need to own a Hacker Pass to submit a vulnerability");
      }
    });
  }, [address]);

  const onSubmitHandler = async (values: SubmittedVulnerability) => {
    values.contestAddress = contest.contestAddress;
    values.ownerAddress = address ?? "";
    values.name = "vuln";

    await fetch("/api/submitted", { method: "POST", body: JSON.stringify(values) });
    router.push("/contests/" + contest.contestAddress);
  };

  if (error) {
    return (
      <Page isMandatoryConnection>
        <main className="flex w-full flex-1 flex-col items-center justify-center p-10">
          <SubHeader>{error}</SubHeader>
        </main>
      </Page>
    );
  }

  return (
    <Page isMandatoryConnection>
      <main className="flex w-full flex-1 flex-col items-center justify-start p-10">
        <DefaultBackground className="flex w-full flex-col gap-8">
          <ContestHeader contest={contest} mode="hacker" />
          <form onSubmit={handleSubmit(onSubmitHandler)} className="flex w-full flex-col gap-8">
            <Input name="name" color="green" label="Title" placeholder="" register={register} />
            <TextArea
              name="proofOfConcept"
              color="green"
              label="Proof of Concept"
              placeholder=""
              className="min-h-[14rem]"
              register={register}
            />
            <Button color="green" type="submit" size="large" className="mx-auto w-fit">
              Submit
            </Button>
          </form>
        </DefaultBackground>
      </main>
    </Page>
  );
};

export const getServerSideProps: GetServerSideProps = async (req) => {
  const contest = await getContestByAddress(req.query.address as string);

  return { props: { contest: JSON.parse(JSON.stringify(contest)) } };
};

export default SubmitVulnerability;
